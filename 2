use std::net::UdpSocket;
use serde::{Deserialize, Serialize};
use serde_json;

#[derive(Serialize, Deserialize, Debug)]
struct Job{
    Work :  String,
    Pool : String,
    Url : String,
    Len : String,
    Error : String
}

pub fn generate_key(KGS_addr : String, pool : String, len : i32) -> std::result::Result<String,String>{
    let socket = UdpSocket::bind("127.0.0.1:3400").expect("couldn't bind to address");
    socket.connect(&KGS_addr).expect("Connection to KGS failed, Maybe KGS is not turned on");
    let request_json_string = format!("{{\"Work\":\"generate\", \"Pool\":\"{}\", \"Len\":\"{}\", \"Url\":\"\"}}", pool, len);
    socket.send(request_json_string.as_bytes()).expect("Error sending messsage to KGS"); 
    let mut kgs_buf = vec![0;1024];
    socket.set_read_timeout(Some(std::time::Duration::from_millis(50))).expect("Internal code error"); //making sure we are bot held up
    let len = match socket.recv(&mut kgs_buf){
        Ok(n) => {
            n
        },
        Err(e) => { 
            println!("Error from key gen service : {}",e);
            return Err(String::from("We are facing some trouble on our side, please try again in a while."));
        }
    };

    let kgs_reply : Job = match String::from_utf8(kgs_buf[0..len].to_vec()){
        Ok(kgs_reply) => { serde_json::from_str(&kgs_reply).expect("Err") },
        Err(e) => {
            println!("Error from KGS (returning invalif utf-8 chats) : {}",e);
            return Err(String::from("We are facing some trouble on our side, please try again in a while."));
        }
    };
    println!("{:?}", kgs_reply);
    Ok(String::from("HEY@#"))
}
